{
"comment": [
        "// Minecraft Shader. Created by Reinder Nijhoff 2013",
        "// @reindernijhoff",
        "//",
        "// https://www.shadertoy.com/view/4ds3WS",
        "//",
        "// port of javascript minecraft: http://jsfiddle.net/uzMPU/",
        "// original code by Markus Persson: https://twitter.com/notch/status/275331530040160256",
        "// combined with voxel-shader by inigo quilez (https://www.shadertoy.com/view/4dfGzs)",
        "//",
        "// All credit goes to inigo quilez!",
        "//"
    ],

"fragment": [
        "precision mediump float;",

        "#define SEA_LEVEL 0.        // anything with y < SEA_LEVEL is a water voxel",
        "#define MAX_STEPS 1024      // max length of vision vector in voxels",
        "#define MAX_DRAW 448.0      // max range for camera drawing",
        "#define CAMERA_SCREEN 3.0   // distance from the camera to the back of the screen",
        "#define SUN_POWER 0.4",
        "#define SUN_SIZE 18.0",
        "#define SKY_COLOUR vec3(0.35,0.47,0.60)",
        "#define GAMMA 0.45",
        "#define HILL_SCALE 24.0     // height gain multiplier for map data",
        "#define COLOUR_SPREAD 0.65  // bands of colour for altitude (larger = wider bands)",

        "// material types for voxels",
        "#define MAT_DIRT 1",
        "#define MAT_STONE 2",
        "#define MAT_WATER 3",
        "#define MAT_CREATURE 4",
        "#define MAT_GRASS 100",

        "// uniform variables sent from JaveScript program",
        "uniform float uGlobalTime;",
        "uniform vec3 uCameraPos;",
        "uniform vec3 uCameraLookAt;",
        "uniform sampler2D uImageSampler;",
        "uniform vec2 uImageSize;",

        "// screen dimensions (constant)",
        "vec2 iResolution = vec2(800.0, 600.0);",

        "// return a tinting colour based on the index provided",
        "vec3 getTint( in int index )",
        "{",
        "    if (index ==  0) return vec3( 96./256.,  32./256.,-128./256.);",
        "    if (index ==  1) return vec3(-96./256., -64./256., -96./256.);",
        "    if (index ==  2) return vec3(-64./256., -16./256., -64./256.);",
        "    if (index ==  3) return vec3(  0./256.,  32./256.,   0./256.);",
        "    if (index ==  4) return vec3( 32./256.,  64./256.,  16./256.);",
        "    if (index ==  5) return vec3( 96./256.,  16./256.,  96./256.);",
        "    if (index ==  6) return vec3( 96./256.,  64./256., 160./256.);",
        "    if (index ==  7) return vec3( 83./256., 128./256., 192./256.);",
        "    if (index ==  8) return vec3( 96./256.,  32./256.,  32./256.);",
        "    if (index ==  9) return vec3(176./256.,  80./256.,  64./256.);",
        "    if (index == 10) return vec3(192./256., 128./256., 112./256.);",
        "    if (index == 11) return vec3(224./256., 128./256., 112./256.);",
        "    if (index == 12) return vec3(192./256., 128./256., 192./256.);",
        "    if (index == 13) return vec3(224./256., 192./256., 224./256.);",
        "    if (index == 14) return vec3(240./256., 224./256., 240./256.);",
        "    return vec3(1., 0.75, 1.);",
        "}",

        "// 'random number' generators using hashes",
        "float hash( in float n ) {",
        "    return fract(sin(n)*43758.5453123);",
        "}",
        "float hash( in vec3 x ) {",
        "    float n = dot( x, vec3(1.0,113.0,257.0) );",
        "    return fract(sin(n)*43758.5453123);",
        "}",
        "vec3 hash3( vec3 n ) {",
        "    return fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));",
        "}",

        "// return the colour of the pixel at coord in material i",
        "vec3 getPixelColour( int i, vec2 coord ) {",
        "    // 16x16 texture coordinates",
        "    vec2 uv = floor( coord );",

        "    // get hash value for stippling and variation",
        "    float h = hash(uv.x + uv.y*347.0 + 4321.0 * float(i));",

        "    // stippling for grass, water, leaves, dirt",
        "    float br = 1. - h * (96./255.);",

        "    // dirt colour by default",
        "    vec3 color = vec3( 128./255., 64./255., 48./255.);",

        "    if (i >= MAT_GRASS) {",
        "        // make jaggy edge for hanging grass",
        "        float xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);",
        "        if ( uv.y < (xm1 + 18.)) {",
        "            // top and grass hanging over edge into top of dirt below",
        "            color = vec3(.1, .3, .05); //vec3( 96./255., 196./255., 64./255.);",
        "        } else if (uv.y < (xm1 + 19.)) {",
        "            // dark shadow underneath hanging grass edge",
        "            br *= .36;",
        "        } else if (uv.y < (xm1 + 21.)) {",
        "            // light shadow underneath hanging grass edge",
        "            br *= .66;",
        "        }",
        "    } else",

        "    if (i == MAT_WATER) {",
        "        // water",
        "        h = hash(mod(uv.x + uGlobalTime * 0.0005, 16.0) + uv.y*347.0 + 4321.0 * float(i));",
        "        br = 1. - h * (96./255.);",
        "        color = vec3(  32./255.,  64./255., 192./255.);",
        "        br = br * 0.25 + 0.2;",
        "    } else",

        "    if (i == MAT_STONE) {",
        "        color = vec3( 96./255., 96./255., 104./255.);",
        "    } else",

        "    if (i == MAT_CREATURE) {",
        "        color = vec3(0.65,0.68,0.7)*1.35;",
        "        br = 1.;",
        "    }",

        "    color *= br;",
        "    return color;",
        "}",

        "bool readMap( in vec3 p, out vec4 oCol ) {",
        "    p.xz /= uImageSize;",
        "    oCol = texture2D( uImageSampler, p.xz );",
        "    if (oCol.a != 0.)",
        "        return (p.y < oCol.r * HILL_SCALE + 1.0);",
        "    return (p.y < oCol.r * HILL_SCALE);",
        "}",

        "bool peekMap( in vec3 p ) {",
        "    p.xz /= uImageSize;",
        "    vec4 col = texture2D( uImageSampler, p.xz );",
        "    return (p.y < col.r * HILL_SCALE);",
        "}",

        "int terrainType( in vec3 p, in vec4 col ) {",
        "    if (col.a == 0.0 || p.y < col.r * HILL_SCALE) return MAT_GRASS;",
        "    return MAT_CREATURE;",
        "}",

        "// oVos and oDir are NOT used if return == 0, faster exit from castRay if no collision",
        "float castRay( in vec3 rayOrigin, in vec3 rayDir, out vec3 oVos, out vec3 oDir, out vec4 oCol ) {",
        "    vec3 pos = floor(rayOrigin);",
        "    vec3 ri = 1.0 / rayDir;",
        "    vec3 rs = sign(rayDir);",
        "    vec3 dis = (pos - rayOrigin + 0.5 + rs * 0.5) * ri;",
        "    vec3 rsi = rs * ri;",
        "    vec3 moveMask = vec3(0.0);",
        "    for( int i=0; i<MAX_STEPS; i++ )",
        "    {",
        "        // which axis to move? (the largest one)",
        "        moveMask = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);",
        "        dis += moveMask * rsi;",
        "        pos += moveMask * rs;",
        "        if ( readMap(pos, oCol) ) {",
        "            // intersect the cube",
        "            vec3 mini = (pos - rayOrigin + 0.5 - 0.5 * vec3(rs)) * ri;",
        "            float t = max ( mini.x, max( mini.y, mini.z ) );",
        "            oDir = moveMask;",
        "            oVos = pos;",
        "            return t;",
        "        }",
        "        if ( distance(pos, rayOrigin) > MAX_DRAW)",
        "            break;",
        "    }",
        "    return 0.;",
        "}",

        "float castVRay( in vec3 rayOrigin, in vec3 rayDir, in float maxDist ) {",
        "    vec4 col;",
        "    vec3 pos = floor(rayOrigin);",
        "    vec3 ri = 1.0/rayDir;",
        "    vec3 rs = sign(rayDir);",
        "    vec3 dis = (pos-rayOrigin + 0.5 + rs*0.5) * ri;",
        "    for( int i=0; i<18; i++ )",
        "    {",
        "        if ( readMap(pos, col) ) { return 0.; }",
        "        vec3 moveMask = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);",
        "        dis += moveMask * rs * ri;",
        "        pos += moveMask * rs;",
        "    }",
        "    return 1.0;",
        "}",

        "varying vec2 v_texcoord;",

        "void main() {",
        "    vec3 sundir = normalize( vec3(-0.5,0.6,0.7) );",

        "    // convert texture coordinate into range -1..+1 in x and y directions",
        "    vec2 q = gl_FragCoord.xy / iResolution;",
        "    vec2 p = vec2(1.0 - 2.0 * q.x, 2.0 * q.y - 1.0);",
        "    // adjust for aspect ratio of the texture",
        "    p.x *= iResolution.x / iResolution.y;",

        "    // camera",
        "    float cameraBank = 0.0;",
        "    vec3 rayOrigin = uCameraPos;",
        "    vec3 target = uCameraLookAt;",
        "    //target.y = rayOrigin.y;",

        "    // build ray",
        "    vec3 ww = normalize(target - rayOrigin);",
        "    vec3 uu = normalize(cross( vec3(sin(cameraBank),cos(cameraBank),0.0), ww ));",
        "    vec3 vv = normalize(cross(ww,uu));",
        "    vec3 rayDir = normalize(p.x*uu + p.y*vv + CAMERA_SCREEN*ww);",

        "    // sky azimuth",
        "    float azimuth = exp(rayDir.y) - 1.0;",
        "    vec3 col = clamp(SKY_COLOUR + vec3(-azimuth * 0.2, -azimuth * 0.2, azimuth * 0.6), 0., 1.);",

        "    // sky sun glare",
        "    float sun = clamp(dot(sundir, rayDir), 0., 1.);",
        "    col = clamp(col + SUN_POWER * vec3(1.0, 1.0, 0.0) * pow( sun, SUN_SIZE ), 0., 1.);",

        "    // cast ray into world and see what it hits first",
        "    // voxelPos and dir are NOT used if t == 0, faster exit from castRay if no collision",
        "    vec3 voxelPos, dir;",
        "    vec4 mapPixelCol;",
        "    float t = castRay( rayOrigin, rayDir, voxelPos, dir, mapPixelCol );",

        "    if ( t > 0. ) {",
        "        vec3 normalVector = -dir * sign(rayDir);",
        "        vec3 pos = rayOrigin + rayDir*t;",
        "        int material = terrainType(voxelPos, mapPixelCol);",

        "        // map conversions, turn grass into dirt, stone, or water",
        "        if ( material == MAT_GRASS) {",
        "            if ( voxelPos.y < SEA_LEVEL )",
        "                material = MAT_WATER;",
        "            else if ( peekMap( voxelPos + vec3(0., 1., 0. ) ) ) {",
        "                if ( peekMap( voxelPos + vec3(0., 2., 0. ) ) )",
        "                    material = MAT_STONE;",
        "                else",
        "                    material = MAT_DIRT;",
        "            }",
        "        }",

        "        vec3 mpos = mod( pos * 16., 16. );",
        "        // use normal of the cube face to determine where the texture comes from",
        "        vec2 textureCoord = (normalVector.y != 0.) ? mpos.xz : (normalVector.x != 0.) ? -mpos.zy + vec2(32., 32.) : -mpos.xy + vec2(32., 32.);",
        "        vec3 materialCol = getPixelColour( material, textureCoord );",

        "        // cube face catches the sun's rays?",
        "        float dif = clamp( dot( normalVector, sundir ), 0.0, 1.0 );",
        "        float sha = 0.0;",
        "        if ( dif > 0.01 ) sha = castVRay( pos + normalVector * 0.01, sundir, 32.0 );",
        "        float bac = clamp( dot( normalVector, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );",
        "        float sky = 0.5 + 0.5 * normalVector.y;",

        "        vec3 lin = vec3(0.0);",
        "        lin += 4.0 * dif * (0.25+0.75*sha);",
        "        lin += 1.8 * bac * vec3(1.0,0.5,1.0);",
        "        lin += 4.0 * sky * vec3(0.4,0.51,0.85);",

        "        // tint grass voxels according to altitude",
        "        if (material >= MAT_GRASS) {",
        "            int index = int(clamp(COLOUR_SPREAD * max(voxelPos.y, SEA_LEVEL), 0., 16.));",
        "            materialCol = clamp(materialCol + 0.25 * getTint(index), 0., 1.);",
        "        }",

        "        if (material == MAT_CREATURE)",
        "        {",
        "            // tint the (naturally white) creatures redder as their energy decreases by removing blue/green from the white",
        "            materialCol = clamp(materialCol - vec3(0., 1. - mapPixelCol.a, 1. - mapPixelCol.a),0., 1.);",
        "        }",
        "        else",
        "        {",
        "            // tint all non-creature voxels increasingly green, according to lushness (food content)",
        "            materialCol = clamp(materialCol + vec3(0., .50 * mapPixelCol.g, 0.), 0., 1.);",
        "        }",

        "        // atmospheric haze... equation obscures details just before the MAX_DRAW distance (fooplot.com)",
        "        col = mix( materialCol*lin*0.2, col, clamp(exp(distance(voxelPos, rayOrigin) * 0.013 - 6.0), 0., 1.) );",
        "    }",

        "    // apply Gamma correction",
        "    col = pow( col, vec3(GAMMA) );",

        "    // adjust contrast",
        "    col = col * 0.15 + 0.85 * col * col * (3.0 - 2.0 * col);",
        "    col = clamp( col, 0.0, 1.0 );",

        "    // vignetting",
        "    //col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );",

        "    gl_FragColor = vec4( col, 1. );",
        "}"

    ],

"vertex": [
        " attribute vec4 aPosition;",
        " varying vec2 v_texcoord;",
        " void main() {",
        "   gl_Position = aPosition;",
        "   v_texcoord = aPosition.xy * 0.5 + 0.5;",
        " }"
    ],

"attributes":
    [ "aPosition" ],
"uniforms":
    [ "uCameraPos", "uCameraLookAt", "uGlobalTime", "uImageSize" ],
"samplers":
    [ "uImageSampler" ]
}
